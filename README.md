# Tinkerbell Language Extensions

Tinkerbell comes with all kinds of sugar to allow writing terser code, that is often more efficient then a plain Haxe counter part.

The sugar is added on a per-class basis:

```
class MyClass implements tink.Lang {
}
```

That means that you can use `tink_lang` granularly. Also, to get rid of sugar in some context, you can prefix it with `@:diet`. This works at class level, field level and 

Generally you should avoid identifiers starting with `__tl_` to avoid conflicts between your code and that generated by tink.

### Overview

- Declaration Sugar 
 - Propety notation
 - Function options
 - Signal/Future sugar
 - Syntactic Delegation
 - ...
- Implementation Sugar
 - Extended loops
  - Extended comprehensions
 - Short lambdas & bind
 - Fallback
 - Trailing argument
- Development tools
- Conventions

And that's it.

# Declaration Sugar

A few general notes/concepts apply:

#### Publishing

Tink has the concept of *publishing* members. This means that a member not explicitly declared `private` is promoted to become `public`, which is contrary to the default in Haxe. Tink does not publish everything by default, but certain sugar makes it sensible to *publish* a field.

#### Inference

Tink also tries to infer types that you omit that would be mandatory. However currently it will not be able to infer an expression that uses members from the class itself.

#### Implicit Return

In many cases, it's obvious that an expression should actually `return` something. Tink handles many of these by implicitly adding return statements should you omit them.

The strategy is all-or-nothing, i.e. if you have *no* return statements, tink will add them. If you have one, tink will leave things as they are.

Examples:

```
{
	if (foo) return 5;
	x;
	y;
	z;
}
```

This will not be touched and will ultimately result in a type error like "Void should be Int".

```
if (foo) 5;
else {
	x;
	y;
	z;
}
```

This will be transformed into:

```
if (foo) return 5;
else {
	x;
	y;
	return z;
}
```

When adding implicit return statements

- to a block, they are added to the last statement
- to an `if`, they are added to the if branch and the else branch if present
- to a `switch`, they are added to each branch
- any other expression is returned directly

As a corrolary, an implicit return of a loop will not lead to meaningful code.

## Property declaration

### Pure calculated properties

You can declare purely calculated properties like this:

```
@:calculated var field:SomeType = someExpr;
```

Calculated properties are [published](#publishing) and can be [infered](#inference) if you omit `SomeType`.

The above code will simply translate into:

```
public var field(get, never):SomeType;
function get_field():SomeType someExpr;
```

Return statements are [added implicitly](#implicit-return) to the getter. You can also use `inline` on the variable which will cause the generation of an `inline` getter. Also `@:calc` is a recognized shortcut.

Here's what happens if we use all of these together:

```
@:calc inline var data = if (Config.IS_LIVE) Data.LIVE else Data.TEST;
```

Assuming `Data.LIVE` and `Data.TEST` are of type `Foo`, this becomes:

```
public var data(get, never):Foo;
inline function get_data()
	if (Config.IS_LIVE) return Data.LIVE;
	else return Data.TEST;
```

### Direct initialization

Tink allows directly initializing fields with three different options:

```
var a:A = _;
var b:B = (defaultB);
var c:C = constantC;
```

So we can initialize fields with:

- `_` : a constructor argument
- `(fallback)` : a constructor argument (or use `fallback` if it is null).
- or an arbitray expression, that must be valid in the context of the constructor

Using any of these has a number of side effects:

- They will generate a constructor if none exists, with a super call if necessary. This can sometimes lead to subtle issues. If you're getting cryptic error messages in complex inheritance chains, look here.
- In the first two cases, they will add an argument to the constructor's argument list and [publish](#publishing) the constructor. Arguments are *appended* in the order of appearence. If you need them to go elsewhere, you can declare your constructor as `function new(before1, before2, _, after1, after2)`, where they will be inserted in order of appearence.
- Any initialization will cause the field to be get an `@:isVar`.

#### Setter Bypass

Direct initialization will cause setter bypass. That means if your field has a setter, it will not be invoked. This is useful if you have the chicken and egg problem that your setter requires the underlying field to be in a particular state to work correctly, but to set that state you would need to call the setter. Well, here you go.

If you don't want setter bypass, initialize the field the old fashioned way - in the constructor body.

### Property notation

#### Readonly property

To denote readonly properties with a getter, you can use this syntax:

```
@:readonly(someExpr) var x:X;
@:readonly var y:Y;
```

Which is converted to:

```
public var x(get, null):X;
public var y(get, null):Y;
function get_x():X someExpr;
function get_y():Y return y;
```

Readonly properties are [published](#publishing), and the getters use [implicit returns](#implicit-return).  
Also, `@:read` is a recognized shortcut.

#### Readwrite properties

```
```

### Sharp properties

New in `tink_lang` for Haxe 3 is the following notation:

```
var x = {
	@get foo * 2;
	@set foo = param / 2;
	@init {
		var o = 3;
		foo = o;
	}
	7;
}
```

This notation is roughly inspired from C# property notation - hence the name. As you can see it is a block that containts an initialization value and 3 different clauses:

- `@get` - If present, will be used to generate the body of the getter and causes [publishing](#publishing). Return will be added implicitly if needed. If you wish to generate a plain getter, use `@get _`. Omission will result in `default` field access. Can be prefixed with `@inline` for an inlined getter
- `@set` - If present, will be used to generate the body of the setter and causes [publishing](#publishing). Return will be added implicitly if needed. If you wish to generate a plain setter, use `@set _`. Omission will result in `null` field access if there is a getter and `default` otherwise. The setter parameter will be called `param`, but you can call it otherwise, by specifying `@set(customName) ...`. Can be prefixed with `@inline` for an inlined setter;
- `@init` - If present, will be used to initialize the field. Technically you can do anything you like in this statement (also it doesn't need to be a block). However, you should use it only to keep code that sets up a member close to that member and not to trigger arbitrary side effects. A good example to use it is to avoid [setter bypass](#setter-bypass)

To intepret this syntax, tink will first peel off the 3 clauses above (all of which are optional). If the remaining block has no statements left, tink stops there. If it has one statement left, then that is considerd the inititialization value, or else the whole block is. That value is processed according to the rules of [direct initialization](#direct-initialization).

#### Sharp notation implementation & details

In fact sharp notation is only a sugar based on [property notation](#property-notation) and [direct intialization](#direct-initialization). If there is an `@init`, it is copied to the constructor. If there is a `@get` and a `@set`, they will be converted to a `@:property` clause. If there is just a `@get`, it will be converted to a `@:readonly` clause. If there is none of both, in fact there will be no property but `(default, default)` access. In that case the field also is not [published](#publishing). The remainder is deleted if it's an empty block, "unpacked" if it's a single statement block or left as is, if

## Function options

You can use the following syntax to add "options" to functions:

```
function foo(i:Int, j:Int, options = [var x:X = someX, var y:Y = someY, ...]) 
	body;

//becomes

function foo(i:Int, j:Int, ?options:{?x:X, ?y:Y}) {
	if (options == null) options = {};
	if (options.x == null) options.x = someX;
	if (options.y == null) options.y = someY;
	body;
}
```

Tink will look at the default values you've defined for your arguments and interpret those that are array literals as options, since they aren't allowed in Haxe.

The accepted entries are either variable declarations or assignments where the left side is an identifier. You can choose to not specify the type, e.g. `[var x = someX, ...` or just write `[x = someX, ...`.
You can also choose not to specify a value for an option. In that case, it will become mandatory and the whole parameter itself will also become mandatory. Example:

```
function foo(options = [var x:X, var y:Y = someY, ...]) 
	body;

//becomes

function foo(options:{ x:X, ?y:Y }) {
	if (options.y == null) options.y = someY;
	body;
}
```

You can specify multiple options if you wish to, although there's no real point in doing that.

### Direct options

If you don't wish to actually have an object holding the options, but rather variables directly, you can use this:

```
function bar(_ = [var x:X = someX, var y:Y = someY, ...]) 
	body;

//becomes

function bar(?_:{?x:X,?y:Y}) {
	var x = if (_ == null || _.x == null) someX else _.x;
	var y = if (_ == null || _.y == null) someY else _.y;
	body;
}
```

This comes pretty close to [named parameters](http://en.wikipedia.org/wiki/Named_parameter). Future versions may use inlining to reduce the overhead completely, but currently that requires enhancements of the compiler's optimizer.

## Signal/Future sugar

...

## Syntactic Delegation

...

# Implementation Sugar

## Extended loops

### Arbitrary steps

Loops with arbitrary steps are denoted as follows:

```
//upward
for (i += step in min...max) body;
//downward
for (i -= step in max...min) body;
```

This also works for float loops. The type of `step` will determine whether this is a `Float` loop or an `Int` loop. The use of `+=` or `-=` determines whether you want an upward or downward loop. Basing this on the sign of `step` would cause rather significant runtime overhead and could also lead to complicated bugs.

The downward loop is symmetrical to the upward loop, i.e. it will yield the same values, only in backward order. A upward loop will always start with min and stop just before max (except in the case of float precision issues), while an upward loop will always end with min, starting just "after" max.

Using this syntax will cause generation of a while loop.

### Key-value loops

This syntax is also supported:

```
for (key => value in target) body;
```

It will just be translated into:

```
for (key in target.keys()) {
    var value = target.get(key);
    body;
}
```

If `target` doesn't actually have a compatible `keys` or `get` method a type error will be generated at the position of where the `key => value` was found.

### Parallel loops

Sometimes you want to iterate over multiple targets at once. Tink supports this syntax:

```
for ([head1, head2, head3]) body;
```

Here `head1`, `head2` and `head3` can be normal loop heads (`variable in expression`) or loop heads for arbitrary step or key-value loops (please note that using parallel loops for key-value loops only makes sense if key order is deterministic, i.e. you're using an ordered map or something).

Example:

```
for ([ship in ships, i -= 1 in ships.length...0])
	ship.x = 30 * i;
```

This will order the ships in your array from right to left.

By default, a parallel loop will stop as soon as any head is "depleted". Another example, to show just that:

```
var girls = ['Lilly', 'Peggy', 'Sue'];
var boys = ['Peter', 'Paul', 'Joe', 'John', 'Jack'];
for ([girl in girls, boy in boys])
    trace(girl + ' loves ' + boy);
-- OUTPUT:
Lilly loves Peter
Peggy loves Paul
Sue loves Joe
```

Now that's really unfortunate for John and Jack. Luckily there's one person they can always lean on: 

```
var girls = ['Lilly', 'Peggy', 'Sue'];
var boys = ['Peter', 'Paul', 'Joe', 'John', 'Jack'];
for ([girl in girls || 'Mommy', boy in boys])
    trace(girl + ' loves ' + boy);
-- OUTPUT:
Lilly loves Peter
Peggy loves Paul
Sue loves Joe
Mommy loves John
Mommy loves Jack
```

#### Loop Fallbacks

As we see in the example just above, we can provide *fallbacks* for parallel loops. We simply use `||` for this. As soon as a loop target is depleted, the fallback expression is used instead. Please note that the expression is evaluated *every time* a fallback value is needed. Example:

```
var girls = ['Lilly', 'Peggy', 'Sue'];
var boys = ['Peter', 'Paul', 'Joe', 'John', 'Jack', 'Jeff', 'Josh'];
var index = 0;
var family = ['Mommy', 'Grandma', 'Aunt Lilly'];
for ([girl in girls || family[index++ % family.length], boy in boys])
    trace(girl + ' loves ' + boy);
-- OUTPUT:
Lilly loves Peter
Peggy loves Paul
Sue loves Joe
Mommy loves John
Grandma loves Jack
Aunt Lilly loves Jeff
Mommy loves Josh
```

This is very powerful, but it's also a great way to shoot yourself in the foot. Please use non-constant expressions with care.

If you specify fallbacks for all targets, the loop will stop as soon as all targets are depleted and only fallbacks are available.

### Loop conversion and optimization

Single key-value loops and single standard loops will just be translated to plain Haxe loops and left for Haxe to deal with. Anything more complex than that becomes a while loop.

To translate for loops to while loops, the Haxe compiler does a bit of optimization, because iterators are not particularly fast. In Haxe, these rules are hard coded. In tink, there are 3 cases (assuming a single loop target for now):

1. Numerical (arbitrary step) loop. This is just hardcoded stuff.
2. The target is not an `Iterator`, but has an `iterator` method, then we look whether the following applies to loop `target.iterator()`:
3. The target is a call to a field, e.g. `target.someField()`, where `someField` has metadata `@:tink_for(init, condition, update)`, then we generate the loop as `{ init; while(condition) update; }`. If the structure does not apply(we can deal with implicit `this` though), or if the field has no `@:tink_for` metadata, we try the following.
4. The target has a `length` and supports array access. Then the loop is implemented with an index iterating through `0...length` and getting the value through array access.
5. If the target is `Iterable` loop over `target.iterator()`
6. If the target is an `Iterator` loop over it with a while loop.
7. Fail and report an error.

For the standard library, tink adds some `@:tink_for` metadata for classes in the std lib where speedup can be achieved.

```
BENCHMARK DATA
```

The generated code is a little more bulky, especially since tink tries hard not to generate conflicts with user variables. Because of that bulkiness and potential incompatibility with plain loops, tink will leave normal loops alone.

If you want to force tink loop optimization, you have two options:

- local optimization, by using the parallel loop syntax with a single head `for ([i in target.keys()]) body`
- global optimization by setting `-D force_tink_loops`

### Extended comprehensions

Tink generalizes the concept of for comprehensions in two ways. It deals with more complex loop bodies and it allows to construct things other than arrays.

#### Complex bodies

Haxe comprehensions are rather narrow in what they accept as bodies. They only accept certain types of if statements, cannot really deal with switches where only some branches yield a value, and also don't properly deal with for loops.

Example with `switch`:

```
var x = [Some(1), None, Some(2)];
trace([for (x in x)
	switch x {
		case Some(v): v;
		default:
	}
]);
```

With tink this traces `"[1, 2]"`, with Haxe it doesn't compile.

Example with arbitrary `if`:

```
typedef Person = { name: String, age:Int, male:Bool }
enum Rescued {
	Woman(person:Person);
	Child(person:Person);
}

var crew:Array<Person> = [/* put some people here */];
var womenAndChildren = [for (person in crew)
	if (person.age < 18) Child(person)
	else if (!person.male) Woman(person)
];
```

With Haxe this will not compile.

#### Alternative output

Haxe comprehensions can only construct maps or arrays. Tink comprehensions have a broader spectrum and deal with maps and arrays as special cases.

The general structure of a tink comprehension is:

```
target.method(for (head) body)
```

This gets translated to somethin like

```
{
	var tmp = target;
	for (head) bodyCallingMethod;
	tmp;
}
```

Where the body is transformed so that the leaf expressions call `tmp.method`.

If the method requires more than one argument, you can use `$(arg1, arg2, arg3)` to yield multiple values. Example:

```
var peopleByName = new Map().set(for (person in people) $(person.name, person));
```

This is translated into:

```
var peopleByName = {
	var tmp = new Map();
	for (person in people) 
		tmp.set(person.name, person);
	tmp;
}
```

When tink encounters `[for (head) body]` it will simply translate it into `[].push(for (head) body)` before processing, and when it encounters something like `[for (head) key => val]` it will translate it into `new Map().set(for (head) $(key, val))`, and they will thus work as though transformed by the Haxe compiler.

But if you need to output a list, you can do:

```
new List().add(for (i in 0...100) i)
```

But you needn't *construct* the target. You can use an existing one. For example to draw a couple of rectangles on the same sprite:

```
sprite.graphics.drawRect(
	for (i in 0...10) 
		$(0, i*10, 100, 10)
)
```

Also, because the target is returned, you can chain stuff:

```
var upAndDown = new List()
	.add(for (i in 0...5) i)
	.add(for (i -= 1 in 5...0) i)
trace(upAndDown);//{0, 1, 2, 3, 4, 4, 3, 2, 1, 0}
```

# Development tools

## Explain

You can use `@:explain` at class, field and 


